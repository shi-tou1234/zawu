<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圣诞祝福 - 粒子动画</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000; 
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        #hint {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 14px; z-index: 10;
            pointer-events: none; transition: opacity 1s;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="hint">✨ 点击屏幕开始 ✨<br><span style="font-size:11px; opacity:0.6">拖拽旋转 · 滚轮缩放 · 点击冲散</span></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ========== 配置 ==========
        const CONFIG = {
            particleCount: 35000,
            snowCount: 1500,
            phases: ['IDLE', 'TEXT1', 'DISSOLVE1', 'TEXT2', 'DISSOLVE2', 'TREE', 'FINAL'],
            phaseDurations: [0.5, 3.5, 1.5, 3.5, 2.5, 6, Infinity],
            treeHeight: 50,
            treeRadius: 22,
        };

        // ========== 全局变量 ==========
        let scene, camera, renderer, composer;
        let particles, particleGeometry, particleMaterial;
        let snowParticles;
        let clock = new THREE.Clock();
        let phase = 0;
        let phaseTime = 0;
        let started = false;
        
        // 鼠标控制
        let cameraDistance = 60; // 当前相机距离
        let targetDistance = 60; // 目标距离
        const minDistance = 25;  // 最近距离
        const maxDistance = 120; // 最远距离
        
        // 鼠标拖拽
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let cameraAngleX = 0;  // 水平旋转角度
        let cameraAngleY = 0;  // 垂直角度
        let targetAngleX = 0;
        let targetAngleY = 0;
        
        // 点击冲散效果
        let explodeTime = 0;       // 冲散计时器
        let explodeActive = false; // 是否正在冲散
        let explodeCenter = new THREE.Vector3(); // 冲散中心点

        // 粒子数据
        let positions, colors, sizes;
        let targetPositions;
        let particleData = []; // 存储每个粒子的额外属性

        // ========== 初始化 ==========
        function init() {
            const canvas = document.getElementById('canvas');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020510);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 55);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // 后处理 - Bloom 发光效果
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloom = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloom.threshold = 0.15;
            bloom.strength = 1.3;
            bloom.radius = 0.8;
            composer.addPass(bloom);

            createParticles();
            createSnow();

            window.addEventListener('resize', onResize);
            canvas.addEventListener('click', startAnimation);
            canvas.addEventListener('touchstart', startAnimation);
            
            // 鼠标滚轮缩放
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                targetDistance += e.deltaY * 0.05;
                targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance));
            }, { passive: false });
            
            // 鼠标拖拽旋转
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // 左键
                    isDragging = true;
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouseX;
                    const deltaY = e.clientY - previousMouseY;
                    
                    targetAngleX += deltaX * 0.01;
                    targetAngleY += deltaY * 0.005;
                    targetAngleY = Math.max(-0.5, Math.min(0.8, targetAngleY)); // 限制垂直角度
                    
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // 触摸拖拽
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && started) {
                    const touch = e.touches[0];
                    if (previousMouseX && previousMouseY) {
                        const deltaX = touch.clientX - previousMouseX;
                        const deltaY = touch.clientY - previousMouseY;
                        targetAngleX += deltaX * 0.01;
                        targetAngleY += deltaY * 0.005;
                        targetAngleY = Math.max(-0.5, Math.min(0.8, targetAngleY));
                    }
                    previousMouseX = touch.clientX;
                    previousMouseY = touch.clientY;
                }
            }, { passive: true });
            
            canvas.addEventListener('touchend', () => {
                previousMouseX = 0;
                previousMouseY = 0;
            });
            
            // 点击冲散效果
            canvas.addEventListener('click', (e) => {
                if (!started) return; // 未开始时不触发
                if (isDragging) return; // 拖拽时不触发
                
                // 将屏幕坐标转换为3D坐标
                const rect = canvas.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );
                
                // 使用射线检测确定3D冲散中心
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // 冲散中心设置在相机前方30单位处
                const dir = raycaster.ray.direction.clone();
                explodeCenter.copy(camera.position).add(dir.multiplyScalar(30));
                
                // 触发冲散
                explodeActive = true;
                explodeTime = 0;
            });
            
            // 防止拖拽结束时触发click
            let dragMoved = false;
            canvas.addEventListener('mousedown', () => { dragMoved = false; });
            canvas.addEventListener('mousemove', () => { if (isDragging) dragMoved = true; });
            canvas.addEventListener('click', (e) => {
                if (dragMoved) e.stopImmediatePropagation();
            }, true);

            animate();
        }

        // ========== 创建主粒子系统 ==========
        function createParticles() {
            const count = CONFIG.particleCount;
            
            particleGeometry = new THREE.BufferGeometry();
            positions = new Float32Array(count * 3);
            colors = new Float32Array(count * 3);
            sizes = new Float32Array(count);
            targetPositions = new Float32Array(count * 3);

            // 初始化粒子 - 散布在空间中
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // 初始位置：从远处飘来
                const r = 60 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                targetPositions[i3] = positions[i3];
                targetPositions[i3 + 1] = positions[i3 + 1];
                targetPositions[i3 + 2] = positions[i3 + 2];

                // 白色
                colors[i3] = 1;
                colors[i3 + 1] = 1;
                colors[i3 + 2] = 1;

                sizes[i] = Math.random() * 0.8 + 0.3;

                // 存储额外数据
                particleData.push({
                    speed: 0.02 + Math.random() * 0.03,
                    offset: Math.random() * Math.PI * 2,
                    originalSize: sizes[i]
                });
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 自定义着色器
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vAlpha;
                    uniform float time;
                    uniform float pixelRatio;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float dist = length(mvPosition.xyz);
                        vAlpha = smoothstep(120.0, 15.0, dist);
                        gl_PointSize = size * pixelRatio * (180.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha *= vAlpha * 0.85;
                        
                        // 柔和发光（提升亮度）
                        vec3 glow = vColor * (1.1 + 0.3 * (1.0 - dist * 2.0));
                        
                        gl_FragColor = vec4(glow, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // ========== 创建飘雪 ==========
        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.snowCount * 3);
            const snowSizes = new Float32Array(CONFIG.snowCount);

            for (let i = 0; i < CONFIG.snowCount; i++) {
                pos[i * 3] = (Math.random() - 0.5) * 120;
                pos[i * 3 + 1] = Math.random() * 80 - 20;
                pos[i * 3 + 2] = (Math.random() - 0.5) * 120;
                snowSizes[i] = Math.random() * 2.5 + 0.5;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));

            const mat = new THREE.ShaderMaterial({
                uniforms: { pixelRatio: { value: renderer.getPixelRatio() } },
                vertexShader: `
                    attribute float size;
                    uniform float pixelRatio;
                    varying float vAlpha;
                    void main() {
                        vec4 mv = modelViewMatrix * vec4(position, 1.0);
                        vAlpha = smoothstep(100.0, 20.0, length(mv.xyz));
                        gl_PointSize = size * pixelRatio * (180.0 / -mv.z);
                        gl_Position = projectionMatrix * mv;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        float d = length(gl_PointCoord - 0.5);
                        if (d > 0.5) discard;
                        float a = 1.0 - smoothstep(0.0, 0.5, d);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, a * 0.5 * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            snowParticles = new THREE.Points(geo, mat);
            snowParticles.visible = false;
            scene.add(snowParticles);
        }

        // ========== 从文字生成粒子目标位置 ==========
        function getTextPositions(text, scale = 1, offsetY = 0) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 150;
            
            canvas.width = 600;
            canvas.height = 300;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${fontSize}px "Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const points = [];

            const step = 2;
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const i = (y * canvas.width + x) * 4;
                    if (imageData.data[i] > 128) {
                        points.push({
                            x: (x - canvas.width / 2) * 0.12 * scale,
                            y: (canvas.height / 2 - y) * 0.12 * scale + offsetY,
                            z: (Math.random() - 0.5) * 3
                        });
                    }
                }
            }

            return points;
        }

        // ========== 生成圣诞树位置 ==========
        function getTreePositions() {
            const points = [];
            const h = CONFIG.treeHeight;
            const r = CONFIG.treeRadius;
            
            // 树身 - 更密集的分层结构
            for (let i = 0; i < 20000; i++) {
                const y = Math.random() * h - h * 0.35;
                const hNorm = (y + h * 0.35) / h;
                
                // 8层分明的树枝
                const numLayers = 8;
                const layerIndex = Math.floor(hNorm * numLayers);
                const layerProgress = (hNorm * numLayers) % 1;
                
                // 每层底部更宽，顶部收窄
                const baseRadius = (1 - layerIndex / numLayers) * r;
                const layerRadius = baseRadius * (1 - layerProgress * 0.25);
                
                // 表面粒子分布
                const actualRadius = layerRadius * (0.8 + Math.random() * 0.4);
                const theta = Math.random() * Math.PI * 2;
                
                points.push({
                    x: Math.cos(theta) * actualRadius,
                    y: y,
                    z: Math.sin(theta) * actualRadius,
                    type: 'tree',
                    layer: layerIndex
                });
            }

            // 树干 - 更粗
            for (let i = 0; i < 800; i++) {
                const y = -h * 0.35 - Math.random() * 8;
                const radius = Math.random() * 3;
                const theta = Math.random() * Math.PI * 2;
                
                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius,
                    type: 'trunk'
                });
            }

            // 顶部星星 - 更大更亮
            const starY = h * 0.65 + 5;
            for (let i = 0; i < 600; i++) {
                const angle = (i / 120) * Math.PI * 2;
                const isOuter = i % 2 === 0;
                const sr = isOuter ? 5 : 2;
                const randomOffset = (Math.random() - 0.5) * 1.2;
                points.push({
                    x: Math.cos(angle) * sr + randomOffset,
                    y: starY + Math.sin(angle * 2.5) * 0.8 + (Math.random() - 0.5) * 1.2,
                    z: Math.sin(angle) * sr + randomOffset,
                    type: 'star'
                });
            }
            
            // 星星光芒射线
            for (let ray = 0; ray < 8; ray++) {
                const rayAngle = (ray / 8) * Math.PI * 2;
                for (let j = 0; j < 30; j++) {
                    const dist = 2 + j * 0.5;
                    points.push({
                        x: Math.cos(rayAngle) * dist,
                        y: starY + (Math.random() - 0.5) * 1.5,
                        z: Math.sin(rayAngle) * dist,
                        type: 'starRay',
                        rayIndex: j
                    });
                }
            }
            
            // 星星光晕
            for (let i = 0; i < 400; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 8;
                points.push({
                    x: Math.cos(angle) * dist * 0.4,
                    y: starY + (Math.random() - 0.5) * 4,
                    z: Math.sin(angle) * dist * 0.4,
                    type: 'starGlow'
                });
            }

            // 蓝色彩灯带 - 更多圈数更密集
            for (let i = 0; i < 800; i++) {
                const t = i / 800;
                const y = t * h * 0.95 - h * 0.33;
                const hNorm = (y + h * 0.35) / h;
                const radius = (1 - hNorm * 0.85) * r + 1.2;
                const theta = t * Math.PI * 24; // 更多圈
                
                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius,
                    type: 'lightStrip',
                    lightIndex: i
                });
            }

            // 金色装饰球 - 更多更大
            for (let i = 0; i < 300; i++) {
                const y = Math.random() * h * 0.88 - h * 0.3;
                const hNorm = (y + h * 0.35) / h;
                const radius = (1 - hNorm * 0.85) * r * 0.85;
                const theta = Math.random() * Math.PI * 2;
                
                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius,
                    type: 'goldBall',
                    ballSize: 0.7 + Math.random() * 0.8
                });
            }

            // 红色装饰球
            for (let i = 0; i < 150; i++) {
                const y = Math.random() * h * 0.85 - h * 0.3;
                const hNorm = (y + h * 0.35) / h;
                const radius = (1 - hNorm * 0.85) * r * 0.88;
                const theta = Math.random() * Math.PI * 2;
                
                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius,
                    type: 'redBall',
                    ballSize: 0.6 + Math.random() * 0.6
                });
            }

            // 彩色小灯珠 - 大量闪烁点
            for (let i = 0; i < 500; i++) {
                const y = Math.random() * h * 0.92 - h * 0.32;
                const hNorm = (y + h * 0.35) / h;
                const radius = (1 - hNorm * 0.85) * r * 0.95;
                const theta = Math.random() * Math.PI * 2;
                
                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius,
                    type: 'tinyLight',
                    colorIndex: Math.floor(Math.random() * 6)
                });
            }

            // 雪花装饰
            for (let i = 0; i < 120; i++) {
                const y = Math.random() * h * 0.75 - h * 0.2;
                const hNorm = (y + h * 0.35) / h;
                const radius = (1 - hNorm * 0.85) * r * 0.9;
                const theta = Math.random() * Math.PI * 2;
                
                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius,
                    type: 'snowflake'
                });
            }

            // 底部光晕效果
            for (let i = 0; i < 300; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * r * 1.5;
                points.push({
                    x: Math.cos(angle) * dist,
                    y: -h * 0.35 + (Math.random() - 0.5) * 3,
                    z: Math.sin(angle) * dist,
                    type: 'groundGlow'
                });
            }

            // 漂浮的光点（树周围）
            for (let i = 0; i < 200; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = r * 1.2 + Math.random() * 10;
                const y = Math.random() * h - h * 0.3;
                points.push({
                    x: Math.cos(angle) * dist,
                    y: y,
                    z: Math.sin(angle) * dist,
                    type: 'floatingLight',
                    floatOffset: Math.random() * Math.PI * 2
                });
            }

            return points;
        }

        // ========== 设置目标位置 ==========
        function setTargetToText(text) {
            const textPoints = getTextPositions(text, 1.3, 0);
            const count = CONFIG.particleCount;
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                if (i < textPoints.length) {
                    const p = textPoints[i % textPoints.length];
                    targetPositions[i3] = p.x;
                    targetPositions[i3 + 1] = p.y;
                    targetPositions[i3 + 2] = p.z;
                    particleData[i].inText = true;
                } else {
                    // 多余粒子在周围漂浮
                    const r = 30 + Math.random() * 50;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                    targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    targetPositions[i3 + 2] = r * Math.cos(phi) - 30;
                    particleData[i].inText = false;
                }
            }
        }

        let treePointsCache = null;
        function setTargetToTree() {
            treePointsCache = getTreePositions();
            const count = CONFIG.particleCount;
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                if (i < treePointsCache.length) {
                    const p = treePointsCache[i];
                    targetPositions[i3] = p.x;
                    targetPositions[i3 + 1] = p.y;
                    targetPositions[i3 + 2] = p.z;
                    particleData[i].treeType = p.type;
                    particleData[i].lightIndex = p.lightIndex;
                    particleData[i].ballColor = p.ballColor;
                } else {
                    // 背景星星
                    const r = 50 + Math.random() * 60;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                    targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    targetPositions[i3 + 2] = r * Math.cos(phi);
                    particleData[i].treeType = 'background';
                }
            }
        }

        function setTargetToScatter() {
            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                // 从当前位置向外扩散
                const cx = positions[i3];
                const cy = positions[i3 + 1];
                const cz = positions[i3 + 2];
                const len = Math.sqrt(cx*cx + cy*cy + cz*cz) || 1;
                const expand = 1.5 + Math.random();
                targetPositions[i3] = cx * expand + (Math.random() - 0.5) * 20;
                targetPositions[i3 + 1] = cy * expand + (Math.random() - 0.5) * 20;
                targetPositions[i3 + 2] = cz * expand + (Math.random() - 0.5) * 20;
            }
        }

        // ========== 颜色设置 ==========
        function setWhiteColor() {
            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                colors[i3] = 1;
                colors[i3 + 1] = 1;
                colors[i3 + 2] = 1;
            }
            particleGeometry.attributes.color.needsUpdate = true;
        }

        function transitionToGold(progress) {
            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                // 白色 -> 金色
                colors[i3] = 1;
                colors[i3 + 1] = 1 - progress * 0.16;
                colors[i3 + 2] = 1 - progress * 0.8;
            }
            particleGeometry.attributes.color.needsUpdate = true;
        }

        function setTreeColors(time) {
            const count = CONFIG.particleCount;
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const data = particleData[i];
                const type = data.treeType;

                if (type === 'star') {
                    // 顶部星星：极亮金黄色
                    const flicker = 0.9 + Math.sin(time * 12 + i * 0.2) * 0.1;
                    colors[i3] = 1.0 * flicker;
                    colors[i3 + 1] = 0.95 * flicker;
                    colors[i3 + 2] = 0.6 * flicker;
                    sizes[i] = data.originalSize * (3.0 + Math.sin(time * 8 + i) * 0.8);
                } else if (type === 'starRay') {
                    // 星星光芒射线 - 金色
                    const rayFade = 1 - (data.rayIndex || 0) / 30;
                    const pulse = 0.7 + Math.sin(time * 6 + i * 0.5) * 0.3;
                    colors[i3] = 1.0 * rayFade * pulse;
                    colors[i3 + 1] = 0.9 * rayFade * pulse;
                    colors[i3 + 2] = 0.4 * rayFade * pulse;
                    sizes[i] = data.originalSize * rayFade * 2.0;
                } else if (type === 'starGlow') {
                    // 星星光晕
                    const glow = 0.4 + Math.sin(time * 5 + i * 0.3) * 0.3;
                    colors[i3] = 0.7 * glow;
                    colors[i3 + 1] = 0.85 * glow;
                    colors[i3 + 2] = 1.0 * glow;
                    sizes[i] = data.originalSize * (1.2 + Math.sin(time * 3 + i) * 0.4);
                } else if (type === 'trunk') {
                    // 树干：深棕色
                    colors[i3] = 0.32;
                    colors[i3 + 1] = 0.2;
                    colors[i3 + 2] = 0.08;
                } else if (type === 'lightStrip') {
                    // 蓝色彩灯带：流动的蓝色光波 - 更亮
                    const phase = (data.lightIndex || 0) * 0.08 + time * 5;
                    const wave = Math.sin(phase) * 0.5 + 0.5;
                    const brightness = 0.6 + wave * 0.4;
                    colors[i3] = 0.3 * brightness;
                    colors[i3 + 1] = 0.8 * brightness;
                    colors[i3 + 2] = 1.0 * brightness;
                    sizes[i] = data.originalSize * (1.8 + wave * 1.2);
                } else if (type === 'goldBall') {
                    // 金色装饰球 - 更鲜明
                    const shimmer = 0.85 + Math.sin(time * 2 + i * 0.6) * 0.15;
                    colors[i3] = 1.0 * shimmer;
                    colors[i3 + 1] = 0.82 * shimmer;
                    colors[i3 + 2] = 0.1 * shimmer;
                    sizes[i] = data.originalSize * (data.ballSize || 1) * 3.5;
                } else if (type === 'redBall') {
                    // 红色装饰球 - 更鲜艳
                    const shimmer = 0.85 + Math.sin(time * 2.5 + i * 0.7) * 0.15;
                    colors[i3] = 1.0 * shimmer;
                    colors[i3 + 1] = 0.1 * shimmer;
                    colors[i3 + 2] = 0.1 * shimmer;
                    sizes[i] = data.originalSize * (data.ballSize || 1) * 3.2;
                } else if (type === 'tinyLight') {
                    // 彩色小灯珠：多彩闪烁 - 更鲜明
                    const colorIndex = data.colorIndex || 0;
                    const blinkPhase = Math.sin(time * 6 + i * 1.5);
                    const blink = blinkPhase > 0.1 ? 1.0 : 0.15;
                    const tinyColors = [
                        [1, 0.1, 0.1],   // 红
                        [0.1, 1, 0.2],   // 绿
                        [0.2, 0.5, 1],   // 蓝
                        [1, 0.95, 0.1],  // 黄
                        [1, 0.3, 0.9],   // 粉
                        [0.1, 1, 1]      // 青
                    ];
                    const c = tinyColors[colorIndex];
                    colors[i3] = c[0] * blink;
                    colors[i3 + 1] = c[1] * blink;
                    colors[i3 + 2] = c[2] * blink;
                    sizes[i] = data.originalSize * (1.5 + (blinkPhase > 0.1 ? 0.6 : 0));
                } else if (type === 'snowflake') {
                    // 雪花装饰：闪亮的白色
                    const sparkle = 0.75 + Math.sin(time * 4 + i * 1.2) * 0.25;
                    colors[i3] = 1.0 * sparkle;
                    colors[i3 + 1] = 1.0 * sparkle;
                    colors[i3 + 2] = 1.0 * sparkle;
                    sizes[i] = data.originalSize * 2.2;
                } else if (type === 'groundGlow') {
                    // 底部光晕
                    const glow = 0.3 + Math.sin(time * 2 + i * 0.5) * 0.15;
                    colors[i3] = 0.4 * glow;
                    colors[i3 + 1] = 0.6 * glow;
                    colors[i3 + 2] = 1.0 * glow;
                    sizes[i] = data.originalSize * 1.5;
                } else if (type === 'floatingLight') {
                    // 漂浮光点
                    const float = 0.4 + Math.sin(time * 1.5 + (data.floatOffset || 0)) * 0.3;
                    colors[i3] = 0.6 * float;
                    colors[i3 + 1] = 0.8 * float;
                    colors[i3 + 2] = 1.0 * float;
                    sizes[i] = data.originalSize * (1.0 + Math.sin(time * 2 + i) * 0.3);
                } else if (type === 'tree') {
                    // 树身：蓝白渐变，带霜雪效果 - 更鲜明
                    const layer = data.layer || 0;
                    const frost = Math.sin(time * 0.4 + i * 0.003) * 0.1;
                    
                    // 从底部深蓝到顶部浅蓝白
                    const layerBlend = layer / 8;
                    const baseBlue = 0.6 + layerBlend * 0.35;
                    const baseWhite = 0.65 + layerBlend * 0.35;
                    
                    // 随机霜雪点
                    const isFrost = (i % 5 === 0);
                    if (isFrost) {
                        colors[i3] = 0.95 + frost;
                        colors[i3 + 1] = 0.98 + frost;
                        colors[i3 + 2] = 1.0;
                    } else {
                        colors[i3] = baseWhite * 0.55 + frost;
                        colors[i3 + 1] = baseWhite * 0.85 + frost;
                        colors[i3 + 2] = baseBlue + 0.45 + frost;
                    }
                } else if (type === 'background') {
                    // 背景星星：微弱闪烁
                    const twinkle = 0.12 + Math.sin(time * 1.0 + i * 0.5) * 0.1;
                    colors[i3] = twinkle * 0.7;
                    colors[i3 + 1] = twinkle * 0.85;
                    colors[i3 + 2] = twinkle * 1.2;
                    sizes[i] = data.originalSize * 0.4;
                }
            }
            
            particleGeometry.attributes.color.needsUpdate = true;
            particleGeometry.attributes.size.needsUpdate = true;
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r, g, b };
        }

        // ========== 开始动画 ==========
        function startAnimation() {
            if (started) return;
            started = true;
            document.getElementById('hint').style.opacity = '0';
            phase = 1;
            phaseTime = 0;
            setTargetToText("祝大家");
            setWhiteColor();
        }

        // ========== 更新阶段 ==========
        function updatePhase(dt) {
            if (!started) return;

            phaseTime += dt;
            const duration = CONFIG.phaseDurations[phase];

            if (phaseTime >= duration && phase < CONFIG.phases.length - 1) {
                phase++;
                phaseTime = 0;

                const newPhase = CONFIG.phases[phase];

                if (newPhase === 'DISSOLVE1') {
                    setTargetToScatter();
                } else if (newPhase === 'TEXT2') {
                    setTargetToText("圣诞快乐");
                } else if (newPhase === 'DISSOLVE2') {
                    setTargetToScatter();
                } else if (newPhase === 'TREE') {
                    setTargetToTree();
                    snowParticles.visible = true;
                }
            }
        }

        // ========== 更新粒子 ==========
        function updateParticles(dt, time) {
            const count = CONFIG.particleCount;
            const phaseName = CONFIG.phases[phase];
            
            const isTreePhase = phaseName === 'TREE' || phaseName === 'FINAL';
            const spiralEffect = phaseName === 'TREE' && phaseTime < 3.5;
            
            // 更新冲散计时器
            if (explodeActive) {
                explodeTime += dt;
                if (explodeTime > 1.5) {
                    explodeActive = false;
                }
            }
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const data = particleData[i];
                
                let tx = targetPositions[i3];
                let ty = targetPositions[i3 + 1];
                let tz = targetPositions[i3 + 2];

                // 螺旋上升效果
                if (spiralEffect) {
                    const progress = Math.min(phaseTime / 3.5, 1);
                    const easeProgress = 1 - Math.pow(1 - progress, 3); // ease out
                    const spiralAngle = easeProgress * Math.PI * 6 + i * 0.005;
                    const spiralRadius = (1 - easeProgress) * 25;
                    
                    tx = tx + Math.cos(spiralAngle + data.offset) * spiralRadius * (1 - easeProgress);
                    tz = tz + Math.sin(spiralAngle + data.offset) * spiralRadius * (1 - easeProgress);
                    ty = ty * easeProgress + positions[i3 + 1] * (1 - easeProgress);
                }
                
                // 点击冲散效果
                if (explodeActive) {
                    const px = positions[i3];
                    const py = positions[i3 + 1];
                    const pz = positions[i3 + 2];
                    
                    // 计算从冲散中心到粒子的方向
                    const dx = px - explodeCenter.x;
                    const dy = py - explodeCenter.y;
                    const dz = pz - explodeCenter.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;
                    
                    // 冲散强度：距离越近越强，时间越早越强
                    const explodeProgress = explodeTime / 1.5;
                    const explodePhase = explodeProgress < 0.3 ? explodeProgress / 0.3 : 1; // 前0.3秒冲散
                    const returnPhase = explodeProgress > 0.3 ? (explodeProgress - 0.3) / 0.7 : 0; // 后0.7秒回归
                    
                    const maxForce = 50 / (dist * 0.1 + 1); // 距离越近力越大
                    const force = maxForce * (1 - returnPhase) * explodePhase;
                    
                    // 应用冲散力
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const nz = dz / dist;
                    
                    positions[i3] += nx * force * dt * 15;
                    positions[i3 + 1] += ny * force * dt * 15;
                    positions[i3 + 2] += nz * force * dt * 15;
                }

                // 缓动 - 冲散时加快回归速度
                const baseEase = isTreePhase ? 0.025 : 0.04;
                const ease = explodeActive ? baseEase * 2 : baseEase;
                positions[i3] += (tx - positions[i3]) * ease;
                positions[i3 + 1] += (ty - positions[i3 + 1]) * ease;
                positions[i3 + 2] += (tz - positions[i3 + 2]) * ease;

                // 微小浮动
                if (phaseName === 'FINAL') {
                    positions[i3] += Math.sin(time * 0.4 + data.offset) * 0.003;
                    positions[i3 + 1] += Math.cos(time * 0.3 + data.offset) * 0.003;
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;

            // 颜色更新
            if (phaseName === 'DISSOLVE2') {
                const progress = Math.min(phaseTime / CONFIG.phaseDurations[phase], 1);
                transitionToGold(progress);
            } else if (isTreePhase) {
                setTreeColors(time);
            }
        }

        // ========== 更新飘雪 ==========
        function updateSnow(dt, time) {
            if (!snowParticles.visible) return;

            const pos = snowParticles.geometry.attributes.position.array;
            const sizes = snowParticles.geometry.attributes.size.array;
            
            for (let i = 0; i < CONFIG.snowCount; i++) {
                const i3 = i * 3;
                
                // 不同大小雪花下落速度不同
                const fallSpeed = 0.05 + (sizes[i] / 3) * 0.05;
                pos[i3 + 1] -= fallSpeed;
                
                // 左右飘动更明显
                pos[i3] += Math.sin(time * 0.6 + i * 0.12) * 0.04;
                // 前后飘动
                pos[i3 + 2] += Math.cos(time * 0.4 + i * 0.18) * 0.03;
                
                // 轻微旋转效果
                const swirl = Math.sin(time * 1.5 + i) * 0.015;
                pos[i3] += swirl;

                // 重置到顶部 - 更大范围
                if (pos[i3 + 1] < -40) {
                    pos[i3 + 1] = 80 + Math.random() * 30;
                    pos[i3] = (Math.random() - 0.5) * 180;
                    pos[i3 + 2] = (Math.random() - 0.5) * 180;
                }
            }
            snowParticles.geometry.attributes.position.needsUpdate = true;
        }

        // ========== 相机动画 ==========
        function updateCamera(time) {
            const phaseName = CONFIG.phases[phase];
            
            // 平滑过渡到目标距离和角度
            cameraDistance += (targetDistance - cameraDistance) * 0.05;
            cameraAngleX += (targetAngleX - cameraAngleX) * 0.08;
            cameraAngleY += (targetAngleY - cameraAngleY) * 0.08;

            if (phaseName === 'FINAL') {
                // 环绕圣诞树 - 支持用户拖拽控制
                const autoAngle = time * 0.1;
                const angle = autoAngle + cameraAngleX; // 用户角度叠加自动旋转
                const radius = cameraDistance;
                const baseY = 12 + Math.sin(time * 0.12) * 4;
                
                camera.position.x = Math.sin(angle) * radius * Math.cos(cameraAngleY);
                camera.position.z = Math.cos(angle) * radius * Math.cos(cameraAngleY);
                camera.position.y = baseY + Math.sin(cameraAngleY) * radius * 0.5;
                camera.lookAt(0, 10, 0);
            } else if (phaseName === 'TREE') {
                // 从非常近的地方拉远 - 更震撼
                const progress = Math.min(phaseTime / 6, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 4);
                
                // 从极近(10)拉远到(60)
                const startRadius = 10;
                const endRadius = 60;
                const radius = startRadius + (endRadius - startRadius) * easeProgress;
                
                // 更新目标距离
                targetDistance = radius;
                cameraDistance = radius;
                
                // 更明显的环绕角度
                const angle = easeProgress * Math.PI * 0.5;
                
                // 相机高度从低处升起
                const startY = -8;
                const endY = 12;
                const camY = startY + (endY - startY) * easeProgress;
                
                camera.position.x = Math.sin(angle) * radius;
                camera.position.z = Math.cos(angle) * radius;
                camera.position.y = camY;
                
                // 视角也随之变化
                const lookY = 3 + easeProgress * 7;
                camera.lookAt(0, lookY, 0);
            } else {
                // 正对文字
                camera.position.x += (0 - camera.position.x) * 0.03;
                camera.position.z += (55 - camera.position.z) * 0.03;
                camera.position.y += (0 - camera.position.y) * 0.03;
                camera.lookAt(0, 0, 0);
            }
        }

        // ========== 动画循环 ==========
        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            particleMaterial.uniforms.time.value = time;

            // 未开始时，粒子轻微漂浮
            if (!started) {
                const count = CONFIG.particleCount;
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    positions[i3] += Math.sin(time * 0.2 + i * 0.01) * 0.01;
                    positions[i3 + 1] += Math.cos(time * 0.15 + i * 0.01) * 0.01;
                }
                particleGeometry.attributes.position.needsUpdate = true;
            } else {
                updatePhase(dt);
                updateParticles(dt, time);
                updateSnow(dt, time);
            }
            
            updateCamera(time);
            composer.render();
        }

        // ========== 窗口调整 ==========
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            particleMaterial.uniforms.pixelRatio.value = renderer.getPixelRatio();
        }

        // 启动
        init();

    </script>
</body>
</html>
